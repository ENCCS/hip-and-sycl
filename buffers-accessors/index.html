<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Data management with buffers and accessors &mdash; Heterogeneous programming with SYCL  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" type="text/css" />
      <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../_static/togglebutton.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sphinx_lesson.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sphinx_rtd_theme_ext_color_contrast.css" type="text/css" />
      <link rel="stylesheet" href="../_static/tabs.css" type="text/css" />
      <link rel="stylesheet" href="../_static/overrides.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script src="../_static/minipres.js"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../_static/togglebutton.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script data-domain="enccs.github.io/sycl-workshop" defer="defer" src="https://plausible.io/js/script.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex/" />
    <link rel="search" title="Search" href="../search/" />
    <link rel="next" title="Data management with unified shared memory" href="../unified-shared-memory/" />
    <link rel="prev" title="Queues, command groups, and kernels" href="../queues-cgs-kernels/" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../" class="icon icon-home">
            Heterogeneous programming with SYCL
              <img src="../_static/ENCCS.jpg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../karolina/">Setting up your system</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">The lesson</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../what-is-sycl/">What is SYCL?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../device-discovery/">Device discovery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../queues-cgs-kernels/">Queues, command groups, and kernels</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Data management with buffers and accessors</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#buffers-and-memory-allocation">Buffers and memory allocation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#buffers-accessors-and-data-movement">Buffers, accessors, and data movement</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../unified-shared-memory/">Data management with unified shared memory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../expressing-parallelism-basic/">Expressing parallelism with SYCL: basic data-parallel kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../expressing-parallelism-nd-range/">Expressing parallelism with SYCL: nd-range data-parallel kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../task-graphs-synchronization/">The task graph: data, dependencies, synchronization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../heat-equation/">Heat equation mini-app</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sub-groups/">Using sub-groups in SYCL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling/">Profiling SYCL applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../buffer-accessor-vs-usm/">Buffer-accessor model <em>vs</em> unified shared memory</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../quick-reference/">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zbibliography/">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guide/">Instructor’s guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../">Heterogeneous programming with SYCL</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Data management with buffers and accessors</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/ENCCS/sycl-workshop/blob/main/content/buffers-accessors.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="data-management-with-buffers-and-accessors">
<span id="buffers-accessors"></span><h1>Data management with buffers and accessors<a class="headerlink" href="#data-management-with-buffers-and-accessors" title="Permalink to this heading"></a></h1>
<div class="admonition-questions questions admonition" id="questions-0">
<p class="admonition-title">Questions</p>
<ul class="simple">
<li><p>What facilities does SYCL offer to manage memory spaces in an heterogeneous environment?</p></li>
</ul>
</div>
<div class="admonition-objectives objectives admonition" id="objectives-0">
<p class="admonition-title">Objectives</p>
<ul class="simple">
<li><p>Learn about the buffer and accessor API.</p></li>
<li><p>Learn how the SYCL runtime manages memory.</p></li>
</ul>
</div>
<p>Heterogeneous computing architectures offer a lot of computational power, but
harnessing it can be highly nontrivial. The existence of <strong>multiple</strong> memory
<em>regions</em> and <em>hierarchies</em> is one of the reasons for this.</p>
<figure class="align-center" id="id5">
<img alt="../_images/CPUAndGPU.png" src="../_images/CPUAndGPU.png" />
<figcaption>
<p><span class="caption-text">A comparison of CPU and GPU architectures.  CPU (left) has complex core
structure and pack several cores on a single chip.  GPU (right) cores are
very simple in comparison, they also share data and control between each
other.  This allows to pack more cores on a single chip, thus achieving very
high compute density. <a class="footnote-reference brackets" href="#id3" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>*<span class="fn-bracket">]</span></a>
Global memory, GPU memory, CPU, and GPU caches have to be managed, more or
less explicitly, by the programmer to achieve optimal performance.</span><a class="headerlink" href="#id5" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Any meaningful computation requires data in input and will produce some data as
output.  There needs to be transfer of data to and from the compute units and
migration of data has an impact on performance.
<a class="reference external" href="https://www.khronos.org/sycl/">SYCL</a> gives us the freedom to decide whether to perform data movements
<strong>explicitly</strong> or <strong>implicitly</strong>. The latter strategy delegates the problem to
the runtime: it reduces the opportunity for data-movement related bugs, but
leaves no room for hand-optimization.
With the former, we retain full control, but we will have to write tedious and
error-prone code for data transfer.</p>
<p>There are three memory-management abstractions in the <a class="reference external" href="https://www.khronos.org/sycl/">SYCL</a> standard:</p>
<ol class="arabic simple">
<li><p><strong>unified shared memory</strong>. This is a pointer-based approach, familiar to
C/C++ programmers and similar to CUDA/HIP low-level languages for
accelerators. USM pointers on the host are valid pointers also on the device.
This is at variance with “classic” pointers in CUDA/HIP.  USM needs device
support for a <em>unified virtual address space</em>.</p></li>
<li><p><strong>the buffer and accessor API</strong>. A <em>buffer</em> is a handle to a 1-, 2-, or
3-dimensional memory location. It specifies where the memory <em>location</em> and
where it can be <em>accessed</em>: host, device or both. As such, the buffer does
not own the memory: it’s only a <em>constrained view</em> into it. We don’t work on
buffer directly, but rather use <em>accessors</em> into them.  This is analogous to
a <a class="reference internal" href="../quick-reference/#term-RAII"><span class="xref std std-term">RAII</span></a>-like approach, similar to what the <a class="reference internal" href="../quick-reference/#term-STL"><span class="xref std std-term">STL</span></a> does in C++.</p></li>
<li><p><strong>images</strong>. They offer a similar API to buffer types, with extra
functionality tailored for image processing. We will not discuss images in
this workshop.</p></li>
</ol>
<p>In this episode, we will look at the buffer and accessor API, while the next
episode <a class="reference internal" href="../unified-shared-memory/#unified-shared-memory"><span class="std std-ref">Data management with unified shared memory</span></a> will discuss of USM. We will compare the
two methods in <a class="reference internal" href="../buffer-accessor-vs-usm/#buffer-accessor-vs-usm"><span class="std std-ref">Buffer-accessor model vs unified shared memory</span></a>.</p>
<section id="buffers-and-memory-allocation">
<h2>Buffers and memory allocation<a class="headerlink" href="#buffers-and-memory-allocation" title="Permalink to this heading"></a></h2>
<p>Buffers are <em>views</em> into already allocated memory: a data abstraction the
runtime uses to represent objects of given C++ types. The view is onto a 1-,
2-, or 3-dimensional array of data. The fact that buffers do not own their
memory has two consequences for their usage:</p>
<ol class="arabic simple">
<li><p>We do not allocate buffers, but rather initialize them from already existing
objects.  Only <a class="reference external" href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable">trivially copyable</a> C++ objects
can be represented in a buffer: the runtime needs to be able to take
byte-by-byte copies.</p></li>
<li><p>We do not access buffers <em>directly</em>, <em>e.g.</em> with a subscript operator or
getters/setters. Rather we use <strong>accessor</strong> objects.</p></li>
</ol>
<p>We construct buffers by specifying their size and what memory they should
provide a view for. The <code class="docutils literal notranslate"><span class="pre">buffer</span></code> class is templated over the type of the
underlying memory and its dimensionality (1, 2, or 3). We give the size as an
object of <code class="docutils literal notranslate"><span class="pre">range</span></code> type: ranges are also used to express parallelism, but we
postpone giving those details until episodes <a class="reference internal" href="../expressing-parallelism-basic/#expressing-parallelism-basic"><span class="std std-ref">Expressing parallelism with SYCL: basic data-parallel kernels</span></a>
and <a class="reference internal" href="../expressing-parallelism-nd-range/#expressing-parallelism-nd-range"><span class="std std-ref">Expressing parallelism with SYCL: nd-range data-parallel kernels</span></a>.</p>
<div class="admonition-some-buffer-constructors signature toggle-shown dropdown admonition" id="signature-0">
<p class="admonition-title">Some <code class="docutils literal notranslate"><span class="pre">buffer</span></code> constructors</p>
<ol class="arabic">
<li><p>We can construct a <code class="docutils literal notranslate"><span class="pre">buffer</span></code> using just a <code class="docutils literal notranslate"><span class="pre">range</span></code>. Data must be
initialized in some other fashion:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">buffer</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">range</span><span class="o">&lt;</span><span class="n">dimensions</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bufferRange</span><span class="p">,</span>
<span class="w">       </span><span class="k">const</span><span class="w"> </span><span class="n">property_list</span><span class="w"> </span><span class="o">&amp;</span><span class="n">propList</span><span class="o">=</span><span class="p">{});</span>
</pre></div>
</div>
</li>
<li><p>We can set the data at construction passing a host pointer and a <code class="docutils literal notranslate"><span class="pre">range</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">buffer</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">hostData</span><span class="p">,</span>
<span class="w">       </span><span class="k">const</span><span class="w"> </span><span class="n">range</span><span class="o">&lt;</span><span class="n">dimensions</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bufferRange</span><span class="p">,</span>
<span class="w">       </span><span class="k">const</span><span class="w"> </span><span class="n">property_list</span><span class="w"> </span><span class="o">&amp;</span><span class="n">propList</span><span class="o">=</span><span class="p">{});</span>
</pre></div>
</div>
</li>
<li><p>We can also pass a <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code> and a <code class="docutils literal notranslate"><span class="pre">range</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">buffer</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">hostData</span><span class="p">,</span>
<span class="w">       </span><span class="k">const</span><span class="w"> </span><span class="n">range</span><span class="o">&lt;</span><span class="n">dimensions</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bufferRange</span><span class="p">,</span>
<span class="w">       </span><span class="k">const</span><span class="w"> </span><span class="n">property_list</span><span class="w"> </span><span class="o">&amp;</span><span class="n">propList</span><span class="o">=</span><span class="p">{});</span>
</pre></div>
</div>
</li>
<li><p>For a one-dimensional <code class="docutils literal notranslate"><span class="pre">buffer</span></code>, a pair of iterators can suffice:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">InputIterator</span><span class="o">&gt;</span>
<span class="n">buffer</span><span class="p">(</span><span class="n">InputIterator</span><span class="w"> </span><span class="n">first</span><span class="p">,</span>
<span class="w">       </span><span class="n">InputIterator</span><span class="w"> </span><span class="n">last</span><span class="p">,</span>
<span class="w">       </span><span class="k">const</span><span class="w"> </span><span class="n">property_list</span><span class="w"> </span><span class="o">&amp;</span><span class="n">propList</span><span class="o">=</span><span class="p">{});</span>
</pre></div>
</div>
</li>
</ol>
</div>
<p>It is worth mentioning that buffer destructors are <strong>blocking</strong>. Thus, in
<a class="reference internal" href="../quick-reference/#term-RAII"><span class="xref std std-term">RAII</span></a> fashion, defining SYCL work within a <code class="docutils literal notranslate"><span class="pre">{}</span></code> block (a new scope)
will ensure that buffers are updated after their data is accessed in a kernel!</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When using a host pointer, we are promising the runtime that we will not
touch the memory during the lifetime of the buffer. It is the programmer’s
responsibility to keep that promise!</p>
</div>
<p>Creation of buffers is just one side of the coin. The buffer is only a view into
memory and no migration of data occurs when we construct one and we cannot
manipulate the underlying data of a buffer directly: both goals are achieved
with <strong>accessors</strong>.</p>
</section>
<section id="buffers-accessors-and-data-movement">
<h2>Buffers, accessors, and data movement<a class="headerlink" href="#buffers-accessors-and-data-movement" title="Permalink to this heading"></a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">buffer</span></code> object “tells” the runtime how the data is laid out, while
<code class="docutils literal notranslate"><span class="pre">accessor</span></code> objects “tell” it how we are going to <em>read from</em> and <em>write to</em>
the underlying memory. This information is crucial for the runtime to correctly
schedule tasks and their execution.  When you define accessors, you are defining
the data dependencies providing edges between the nodes in the task graph.
Accessor objects are templated over five parameters:</p>
<ul class="simple">
<li><p>the type and the dimension, which will be the same as for the underlying
buffer.</p></li>
<li><p>the <strong>access mode</strong>: how do we intend to access the data in the
buffer? The possible values are <code class="docutils literal notranslate"><span class="pre">read</span></code>, <code class="docutils literal notranslate"><span class="pre">write</span></code>, and <code class="docutils literal notranslate"><span class="pre">read_write</span></code> for
read-only (default for <code class="docutils literal notranslate"><span class="pre">const</span></code> data types), for write-only, and for
read-write (default for non-<code class="docutils literal notranslate"><span class="pre">const</span></code> data types) access, respectively.</p></li>
<li><p>the <strong>access target</strong>: what memory and where do we intend to access? The
default is <code class="docutils literal notranslate"><span class="pre">global_memory</span></code> stating that the data resides in the device
global memory space.</p></li>
<li><p>the <strong>placeholder</strong> status: is this accessor a placeholder or not? We will not
look at this parameter in detail. <a class="footnote-reference brackets" href="#id4" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>†<span class="fn-bracket">]</span></a></p></li>
</ul>
<p>Device accessors can be created within a command group, for example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">buffer</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">{</span><span class="n">range</span><span class="p">{</span><span class="mi">42</span><span class="p">}};</span>

<span class="n">Q</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cgh</span><span class="p">){</span>
<span class="w">   </span><span class="n">accessor</span><span class="w"> </span><span class="n">aA</span><span class="p">{</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">cgh</span><span class="p">};</span>
<span class="p">});</span>
</pre></div>
</div>
<p>you can notice that <a class="reference internal" href="../quick-reference/#term-CTAD"><span class="xref std std-term">CTAD</span></a> and default template parameters help out here
and avoid us the tedious task of specifying all template parameters.  The
accessor <code class="docutils literal notranslate"><span class="pre">aA</span></code> is in <code class="docutils literal notranslate"><span class="pre">read_write</span></code> mode, with target <code class="docutils literal notranslate"><span class="pre">global_memory</span></code>.</p>
<p>The SYCL standard provides convenient <em>access tags</em> to specify both access
<em>mode</em> and <em>target</em> upon construction.</p>
<table class="docutils align-default" id="id6">
<caption><span class="caption-text">Available access tags</span><a class="headerlink" href="#id6" title="Permalink to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Tag value</p></th>
<th class="head"><p>Access mode</p></th>
<th class="head"><p>Access target</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">read_write</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">read_write</span></code></p></td>
<td><p>default</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">read_only</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">read</span></code></p></td>
<td><p>default</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">write_only</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">write</span></code></p></td>
<td><p>default</p></td>
</tr>
</tbody>
</table>
<p>This avoids having to give the template arguments explicitly and saves quite a
bit of typing!</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">buffer</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">{</span><span class="n">range</span><span class="p">{</span><span class="mi">42</span><span class="p">}};</span>

<span class="n">Q</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cgh</span><span class="p">){</span>
<span class="w">   </span><span class="k">auto</span><span class="w"> </span><span class="n">aAA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">accessor</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">cgh</span><span class="p">,</span><span class="w"> </span><span class="n">write_only</span><span class="p">,</span><span class="w"> </span><span class="n">no_init</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">no_init</span></code> property tells the runtime to discard whatever previous contents
of the underlying buffer, which can lead to fewer data movements.</p>
<p>Finally, we use objects of type <code class="docutils literal notranslate"><span class="pre">host_accessor</span></code> to read data on the host from
a buffer previously accessed on a device:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">buffer</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">{</span><span class="n">range</span><span class="p">{</span><span class="mi">42</span><span class="p">}};</span>

<span class="n">Q</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cgh</span><span class="p">){</span>
<span class="w">   </span><span class="n">accessor</span><span class="w"> </span><span class="n">aA</span><span class="p">{</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">cgh</span><span class="p">};</span>

<span class="w">   </span><span class="c1">// fill buffer</span>
<span class="w">   </span><span class="n">cgh</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">(</span><span class="n">range</span><span class="p">{</span><span class="mi">42</span><span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">idx</span><span class="p">){</span>
<span class="w">     </span><span class="n">aA</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">42.0</span><span class="p">;</span>
<span class="w">   </span><span class="p">})</span>
<span class="p">});</span>

<span class="n">host_accessor</span><span class="w"> </span><span class="n">result</span><span class="p">{</span><span class="n">A</span><span class="p">};</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>These objects are similar to device accessors, but you will note that they are
constructed with just a buffer as argument. Further, we inspect the
contents of the buffer directly, even though we didn’t put buffer and queue
submission in a separate scope, nor did we wait on the queue.
The constructor for the <code class="docutils literal notranslate"><span class="pre">host_accessor</span></code> implicitly waits for the data to be
available.</p>
<p>None of the examples above invoked functions for memory movement between host
and device: the buffer and accessor API completely relieves us from this
burdensome aspect of heterogeneous programming.</p>
<div class="admonition-axpy-with-sycl-buffers-and-accessors exercise important admonition" id="exercise-0">
<p class="admonition-title">AXPY with SYCL buffers and accessors</p>
<p>We will now write an AXPY implementation in <a class="reference external" href="https://www.khronos.org/sycl/">SYCL</a>, using the buffer and
accessor API. Given a scalar, <span class="math notranslate nohighlight">\(\alpha\)</span>, and two vectors, <span class="math notranslate nohighlight">\(x\)</span> and
<span class="math notranslate nohighlight">\(y\)</span> , AXPY performs the following operation:</p>
<div class="math notranslate nohighlight">
\[y := \alpha x + y\]</div>
<p>This will be a generic implementation: it will work with any
arithmetic type, thanks to C++ templates.</p>
<p><strong>Don’t do this at home, use optimized BLAS!</strong></p>
<p>You can find a scaffold for the code in the
<code class="docutils literal notranslate"><span class="pre">content/code/day-1/05_axpy-buf_acc/axpy.cpp</span></code> file, alongside the CMake script
to build the executable. You will have to complete the source code to compile
and run correctly: follow the hints in the source file.
The code fills two <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> objects and passes them to the <code class="docutils literal notranslate"><span class="pre">axpy</span></code>
function, which accepts a <code class="docutils literal notranslate"><span class="pre">queue</span></code> object as first parameter.
You have to complete this function:</p>
<ol class="arabic simple">
<li><p>Define buffers to view into the input and output vectors.</p></li>
<li><p>Schedule work on the <code class="docutils literal notranslate"><span class="pre">queue</span></code> using a command group.</p></li>
<li><p>Define accessors to the input and output vectors, with proper access mode
and target.</p></li>
<li><p>Write the AXPY kernel as a lambda function.</p></li>
<li><p>Return the computed value.</p></li>
</ol>
<p>A working solution is in the <code class="docutils literal notranslate"><span class="pre">solution</span></code> subfolder.</p>
</div>
<div class="admonition-keypoints keypoints admonition" id="keypoints-0">
<p class="admonition-title">Keypoints</p>
<ul class="simple">
<li><p>Buffers and accessors delegate memory management issues to the SYCL runtime.</p></li>
<li><p>SYCL lets you abstract away the intricacies of host-device data dependencies.</p></li>
<li><p>It can be hard to adapt an existing code to the buffer-accessor model.</p></li>
<li><p>There might be performance overhead when adopting the buffer-accessor model.</p></li>
</ul>
</div>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">*</a><span class="fn-bracket">]</span></span>
<p>Reproduced, with permission, from the training material for the <a class="reference external" href="https://enccs.github.io/CUDA/1.01_GPUIntroduction/#graphics-processing-units">ENCCS CUDA workshop</a>.</p>
</aside>
<aside class="footnote brackets" id="id4" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">†</a><span class="fn-bracket">]</span></span>
<p>A placeholder accessor is a device accessor that can be declared outside
of a command group. Placeholder accessors are reusable, but you need to
intervene explicitly on the task graph (the <code class="docutils literal notranslate"><span class="pre">require</span></code> method on the
<code class="docutils literal notranslate"><span class="pre">handler</span></code> class) to set a data dependency.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">buffer</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">{</span><span class="n">range</span><span class="p">{</span><span class="mi">42</span><span class="p">}};</span>

<span class="n">accessor</span><span class="w"> </span><span class="n">pA</span><span class="p">{</span><span class="n">A</span><span class="p">};</span>

<span class="n">Q</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">handler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cgh</span><span class="p">){</span>
<span class="w">   </span><span class="n">cgh</span><span class="p">.</span><span class="n">require</span><span class="p">(</span><span class="n">pA</span><span class="p">);</span>
<span class="w">   </span><span class="n">cgh</span><span class="p">.</span><span class="n">paralell_for</span><span class="p">(</span><span class="cm">/* data-parallel kernel */</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
</aside>
</aside>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../queues-cgs-kernels/" class="btn btn-neutral float-left" title="Queues, command groups, and kernels" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../unified-shared-memory/" class="btn btn-neutral float-right" title="Data management with unified shared memory" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Roberto Di Remigio and individual contributors..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>