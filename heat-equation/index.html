<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Heat equation mini-app &mdash; Heterogeneous programming with SYCL  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" type="text/css" />
      <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../_static/togglebutton.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sphinx_lesson.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sphinx_rtd_theme_ext_color_contrast.css" type="text/css" />
      <link rel="stylesheet" href="../_static/tabs.css" type="text/css" />
      <link rel="stylesheet" href="../_static/overrides.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script src="../_static/minipres.js"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../_static/togglebutton.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script data-domain="enccs.github.io/sycl-workshop" defer="defer" src="https://plausible.io/js/script.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex/" />
    <link rel="search" title="Search" href="../search/" />
    <link rel="next" title="Using sub-groups in SYCL" href="../sub-groups/" />
    <link rel="prev" title="The task graph: data, dependencies, synchronization" href="../task-graphs-synchronization/" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../" class="icon icon-home">
            Heterogeneous programming with SYCL
              <img src="../_static/ENCCS.jpg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../karolina/">Setting up your system</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">The lesson</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../what-is-sycl/">What is SYCL?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../device-discovery/">Device discovery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../queues-cgs-kernels/">Queues, command groups, and kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../buffers-accessors/">Data management with buffers and accessors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../unified-shared-memory/">Data management with unified shared memory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../expressing-parallelism-basic/">Expressing parallelism with SYCL: basic data-parallel kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../expressing-parallelism-nd-range/">Expressing parallelism with SYCL: nd-range data-parallel kernels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../task-graphs-synchronization/">The task graph: data, dependencies, synchronization</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Heat equation mini-app</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">Heat equation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-partial-differential-equation">The partial differential equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spatial-boundary-conditions">Spatial boundary conditions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-source-code">The source code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#building-the-code">Building the code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#running-the-code">Running the code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initial-and-boundary-conditions">Initial and boundary conditions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#writing-a-sycl-port">Writing a SYCL port</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../sub-groups/">Using sub-groups in SYCL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../profiling/">Profiling SYCL applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../buffer-accessor-vs-usm/">Buffer-accessor model <em>vs</em> unified shared memory</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../quick-reference/">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zbibliography/">Bibliography</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guide/">Instructor’s guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../">Heterogeneous programming with SYCL</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Heat equation mini-app</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/ENCCS/sycl-workshop/blob/main/content/heat-equation.rst" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="heat-equation-mini-app">
<span id="heat-equation"></span><h1>Heat equation mini-app<a class="headerlink" href="#heat-equation-mini-app" title="Permalink to this heading"></a></h1>
<div class="admonition-objectives objectives admonition" id="objectives-0">
<p class="admonition-title">Objectives</p>
<ul class="simple">
<li><p>Understand the structure of a mini-app that models heat diffusion</p></li>
<li><p>Understand how the 5-point stencil operates</p></li>
<li><p>Understand that the loops influence the duration of the mini-app</p></li>
<li><p>Understand the expected output of the mini-app</p></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This episode was adapted, with permission, from the <a class="reference external" href="https://enccs.github.io/openmp-gpu/">ENCCS/CSC workshop on
OpenMP for GPU offloading</a>.  CSC
staff developed the serial version of the mini-app, under MIT license. We
reproduce it with permission.</p>
</div>
<section id="id1">
<h2>Heat equation<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h2>
<p>Heat flows in objects according to local temperature differences, as if seeking
local equilibrium.
Such processes can be modelled with partial differential equations via
discretization to a regular grid.
Solving for the flow over time can involve a lot of computational effort.
Fortunately that effort is quite regular and so can suit parallelization with a
variety of techniques, <a class="reference external" href="https://www.khronos.org/sycl/">SYCL</a> included.</p>
<section id="the-partial-differential-equation">
<h3>The partial differential equation<a class="headerlink" href="#the-partial-differential-equation" title="Permalink to this heading"></a></h3>
<p>The rate of change of the temperature field <span class="math notranslate nohighlight">\(u(x, y, t)\)</span> over two spatial
dimensions <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> and time <span class="math notranslate nohighlight">\(t\)</span>
with diffusivity <span class="math notranslate nohighlight">\(\alpha\)</span> can be modelled via the equation</p>
<div class="math notranslate nohighlight">
\[\frac{\partial u}{\partial t} = \alpha \nabla^2 u\]</div>
<p>where <span class="math notranslate nohighlight">\(\nabla\)</span> is the Laplacian operator, which describes how
the temperature field varies with the spatial dimensions <span class="math notranslate nohighlight">\(x\)</span> and
<span class="math notranslate nohighlight">\(y\)</span>. When those are continuous variables, that looks like</p>
<div class="math notranslate nohighlight">
\[\frac{\partial u}{\partial t} = \alpha \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial x^2}\right)\]</div>
<p>Because computers are finite devices, we often need to solve such equations
numerically, rather than analytically.
This often involves <em>discretization</em>, where spatial and temporal variables only
take on specific values from a set.
In this mini-app we will discretize all three dimensions <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>,
and <span class="math notranslate nohighlight">\(t\)</span>, such that</p>
<div class="math notranslate nohighlight">
\[\begin{split}\nabla^2 u  &amp;= \frac{u(i-1,j)-2u(i,j)+u(i+1,j)}{(\Delta x)^2} \\
    &amp;+ \frac{u(i,j-1)-2u(i,j)+u(i,j+1)}{(\Delta y)^2}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(u(i,j)\)</span> refers to the temperature at location with
integer index <span class="math notranslate nohighlight">\(i\)</span> within the domain of <span class="math notranslate nohighlight">\(x\)</span> spaced by
<span class="math notranslate nohighlight">\(\Delta x\)</span> and location with integer index <span class="math notranslate nohighlight">\(j\)</span> within the
domain of <span class="math notranslate nohighlight">\(y\)</span> spaced by <span class="math notranslate nohighlight">\(\Delta y\)</span>.</p>
<p>Given an initial condition <span class="math notranslate nohighlight">\((u^{t=0})\)</span>, one can follow the time
dependence of the temperature field from state <span class="math notranslate nohighlight">\(m\)</span> to
<span class="math notranslate nohighlight">\(m+1\)</span> over regular time steps <span class="math notranslate nohighlight">\(\Delta t\)</span> with explicit
time evolution method:</p>
<div class="math notranslate nohighlight">
\[u^{m+1}(i,j) = u^m(i,j) + \Delta t \alpha \nabla^2 u^m(i,j)\]</div>
<p>This equation expresses that the time evolution of the temperature
field at a particular location depends on the value of the field at
the previous step at the same location <em>and</em> four adjacent locations:</p>
<figure class="align-center" id="id4">
<img alt="../_images/stencil.svg" src="../_images/stencil.svg" /><figcaption>
<p><span class="caption-text">This example model uses an 8x8 grid of data in light blue in state
<span class="math notranslate nohighlight">\(m\)</span>, each location of which has to be updated based on the
indicated 5-point stencil in yellow to move to the next time point
<span class="math notranslate nohighlight">\(m+1\)</span>.</span><a class="headerlink" href="#id4" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<div class="admonition-exercise exercise important admonition" id="exercise-0">
<p class="admonition-title">Exercise</p>
<p>How much arithmetic must be done to evolve each location at each time step?</p>
</div>
<div class="admonition-solution solution important dropdown admonition" id="solution-0">
<p class="admonition-title">Solution</p>
<p>10 arithmetic operations per location per time step. 3 in each of 2
numerators, 1 to divide by each pre-computed denominator, and two
additions to update <span class="math notranslate nohighlight">\(u\)</span>.</p>
</div>
<div class="admonition-exercise exercise important admonition" id="exercise-1">
<p class="admonition-title">Exercise</p>
<p>How much arithmetic must be done to evolve all locations in the grid for 20 steps?</p>
</div>
<div class="admonition-solution solution important dropdown admonition" id="solution-1">
<p class="admonition-title">Solution</p>
<p>There’s 64 locations and 20 steps and each does the same 10
operations, so <span class="math notranslate nohighlight">\(10*8*8*20 = 12800\)</span> arithmetic operations
total.</p>
</div>
</section>
<section id="spatial-boundary-conditions">
<h3>Spatial boundary conditions<a class="headerlink" href="#spatial-boundary-conditions" title="Permalink to this heading"></a></h3>
<p>Something must happen at the edges of the grid so that the stencil does a valid
operation.  One alternative is to ignore the contribution of points that are
outside the grid.  However, this tends to complicate the implementation of the
stencil and is also often non-physical.  In a real problem, there is always
somethign outside the grid!  Sometimes it makes sense to have periodic
boundaries to the grid, but that is complex to implement.  In this mini-app, we
will have a ring of data points around the grid.  Those will have a fixed value
that is not updated by the stencil, although they do contribute to the stencil
operation for their neighbors.</p>
<figure class="align-center" id="id5">
<img alt="../_images/stencil-fixed-boundaries.svg" src="../_images/stencil-fixed-boundaries.svg" /><figcaption>
<p><span class="caption-text">This example model uses an 8x8 grid of data in light blue with an
outer ring in red of boundary grid sites whose temperature values
are fixed. This lets the stencil operate on the blue region in a
straightforward way.</span><a class="headerlink" href="#id5" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="the-source-code">
<h3>The source code<a class="headerlink" href="#the-source-code" title="Permalink to this heading"></a></h3>
<p>Now we’ll take a look at the source code that will do this for us!
Let’s look at the data structure describing the field:</p>
<div class="admonition-the-field-data-structure typealong toggle-shown dropdown admonition" id="typealong-0">
<p class="admonition-title">The field data structure</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">field</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// nx and ny are the dimensions of the field. The array data</span>
<span class="w">  </span><span class="c1">// contains also ghost layers, so it will have dimensions nx+2 x ny+2</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ny</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Size of the grid cells</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dy</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// The temperature values in the 2D grid</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<p>Next, the routine that applies the stencil to the previous field to compute the current one:</p>
<div class="admonition-the-core-evolution-operation typealong toggle-shown dropdown admonition" id="typealong-1">
<p class="admonition-title">The core evolution operation</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">evolve</span><span class="p">(</span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Help the compiler avoid being confused by the structs</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">currdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">prevdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nx</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">nx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ny</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">ny</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Determine the temperature field at next time step</span>
<span class="w">  </span><span class="c1">// As we have fixed boundary conditions, the outermost gridpoints</span>
<span class="w">  </span><span class="c1">// are not updated.</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dy2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dy</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">ind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">ip</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">im</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">jp</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">jm</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="n">currdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">*</span>
<span class="w">          </span><span class="p">((</span><span class="n">prevdata</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">im</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">+</span>
<span class="w">           </span><span class="p">(</span><span class="n">prevdata</span><span class="p">[</span><span class="n">jp</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">jm</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dy2</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Then the routine that handles the main loop over time steps:</p>
<div class="admonition-the-main-driver-function typealong toggle-shown dropdown admonition" id="typealong-2">
<p class="admonition-title">The main driver function</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// Number of time steps</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nsteps</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Current and previous temperature fields</span>
<span class="w">  </span><span class="n">field</span><span class="w"> </span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="n">previous</span><span class="p">;</span>
<span class="w">  </span><span class="n">initialize</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">previous</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nsteps</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Diffusion constant</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Compute the largest stable time step</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="n">dx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="n">dx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dy2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="n">dy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">current</span><span class="p">.</span><span class="n">dy</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Time step</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dy2</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">dx2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dy2</span><span class="p">));</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wall_clock_t</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Time evolution</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nsteps</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">evolve</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">previous</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">image_interval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">write_field</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="n">iter</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Swap current field so that it will be used</span>
<span class="w">    </span><span class="c1">// as previous for next iteration step</span>
</pre></div>
</div>
</div>
<p>There’s other supporting code to handle user input and produce nice images of
the current field, but we won’t need to touch those, so we won’t spend time
looking at them now.
In the real version of the code we have seen, there’s also calls to libraries to
record the time taken.  We’ll need that later so we understand how fast our code
is.</p>
<p>We should look at the routines that initialize the field data structures:</p>
<div class="admonition-the-setup-routines typealong toggle-shown dropdown admonition" id="typealong-3">
<p class="admonition-title">The setup routines</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Allocate memory for a temperature field and initialise it to zero</span>
<span class="kt">void</span>
<span class="nf">allocate_field</span><span class="p">(</span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">temperature</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Include also boundary layers</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">newSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">temperature</span><span class="o">-&gt;</span><span class="n">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">temperature</span><span class="o">-&gt;</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">  </span><span class="n">temperature</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">newSize</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="building-the-code">
<h3>Building the code<a class="headerlink" href="#building-the-code" title="Permalink to this heading"></a></h3>
<p>The code is set up so that you can change to its directory
and build as follows.</p>
<div class="admonition-building-the-code typealong toggle-shown dropdown admonition" id="typealong-4">
<p class="admonition-title">Building the code</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>cmake<span class="w"> </span>-S.<span class="w"> </span>-Bbuild
$<span class="w"> </span>cmake<span class="w"> </span>--build<span class="w"> </span>build
</pre></div>
</div>
</div>
<p>which produces an executable program called <code class="docutils literal notranslate"><span class="pre">heat</span></code> in the <code class="docutils literal notranslate"><span class="pre">build</span></code> folder.
The app can be built with visualization support. <a class="footnote-reference brackets" href="#id3" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>*<span class="fn-bracket">]</span></a></p>
</section>
<section id="running-the-code">
<h3>Running the code<a class="headerlink" href="#running-the-code" title="Permalink to this heading"></a></h3>
<p>The code lets you choose the spatial dimensions and the number of time steps on the command line.
For example, to run an 800 by 800 grid for 1000 steps, run</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./heat<span class="w"> </span><span class="m">800</span><span class="w"> </span><span class="m">800</span><span class="w"> </span><span class="m">1000</span>
</pre></div>
</div>
<p>Try it now!</p>
<div class="admonition-exercise exercise important admonition" id="exercise-2">
<p class="admonition-title">Exercise</p>
<p>How long does the iteration take if you double the number of steps?
How long does the iteration take if you double the number of grid points in each direction?</p>
</div>
<div class="admonition-solution solution important dropdown admonition" id="solution-2">
<p class="admonition-title">Solution</p>
<p>Doubling the number of steps doubles the total amount of work, so should take around twice as long.
Doubling both numbers of grid points is four times as much work, so should take around four times as long.</p>
</div>
<p>You can see the output on the terminal, like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Average</span> <span class="n">temperature</span> <span class="n">at</span> <span class="n">start</span><span class="p">:</span> <span class="mf">59.762281</span>
<span class="n">Iterations</span> <span class="n">took</span> <span class="mf">0.426</span> <span class="n">seconds</span><span class="o">.</span>
<span class="n">Average</span> <span class="n">temperature</span><span class="p">:</span> <span class="mf">58.065097</span>
</pre></div>
</div>
<p>This report will help us check whether our attempts to optimize made the code faster while keepint it correct.</p>
</section>
<section id="initial-and-boundary-conditions">
<h3>Initial and boundary conditions<a class="headerlink" href="#initial-and-boundary-conditions" title="Permalink to this heading"></a></h3>
<p>When solving PDEs, the initial conditions determine the possible solutions.
The mini-app automatically sets up a disk of cold grid points in the center at
temperature 5, with warm grid points around it at temperature 65.</p>
<figure class="align-center" id="id6">
<a class="reference internal image-reference" href="../_images/heat_0000.png"><img alt="../_images/heat_0000.png" src="../_images/heat_0000.png" style="width: 400.0px; height: 400.0px;" /></a>
<figcaption>
<p><span class="caption-text">Initial conditions of the grid.
The boundary layers are not shown.</span><a class="headerlink" href="#id6" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>There is a fixed boundary layer of one grid point on all sides, two of which are
warm (temperature 70 and 85) and two cold (temperature 20 and 5).
Early on, the disk and its surroundings dominate the contents of the grid, but
over time, the boundary layers have greater and greater influence.</p>
<div class="admonition-exercise exercise important admonition" id="exercise-3">
<p class="admonition-title">Exercise</p>
<p>To which average temperature will the grid converge?</p>
</div>
<div class="admonition-solution solution important dropdown admonition" id="solution-3">
<p class="admonition-title">Solution</p>
<p>Eventually, the boundary conditions will dominate.
Each contributes equally if the sides are of equal length.  The average of
the grid will be the average of the boundaries, ie. <span class="math notranslate nohighlight">\((70+20+85+5)/4\)</span>
which is <span class="math notranslate nohighlight">\(45\)</span>.</p>
</div>
</section>
</section>
<section id="writing-a-sycl-port">
<h2>Writing a SYCL port<a class="headerlink" href="#writing-a-sycl-port" title="Permalink to this heading"></a></h2>
<p>We are now ready to write a SYCL port of the heat equation mini-app. We will start by using the buffer and accessor model and will look into using USM at a later stage, see <a class="reference internal" href="../buffer-accessor-vs-usm/#buffer-accessor-vs-usm"><span class="std std-ref">Buffer-accessor model vs unified shared memory</span></a>.</p>
<p>Before starting to work with the code, consider:</p>
<ol class="arabic">
<li><p>Which kernel should be ported first?
The time evolution is essentially serial:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wall_clock_t</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Time evolution</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">nsteps</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">evolve</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">previous</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">dt</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">image_interval</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">write_field</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="n">iter</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// Swap current field so that it will be used</span>
<span class="w">    </span><span class="c1">// as previous for next iteration step</span>
</pre></div>
</div>
<p>The stencil application will be our target for parallelization with SYCL:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span>
<span class="nf">evolve</span><span class="p">(</span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">curr</span><span class="p">,</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Help the compiler avoid being confused by the structs</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">currdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">prevdata</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nx</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">nx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ny</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">ny</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Determine the temperature field at next time step</span>
<span class="w">  </span><span class="c1">// As we have fixed boundary conditions, the outermost gridpoints</span>
<span class="w">  </span><span class="c1">// are not updated.</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dx</span><span class="p">;</span>
<span class="w">  </span><span class="kt">double</span><span class="w"> </span><span class="n">dy2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dy</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">ind</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">ip</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">im</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">jp</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">jm</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ny</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="n">currdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">*</span>
<span class="w">          </span><span class="p">((</span><span class="n">prevdata</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">im</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">+</span>
<span class="w">           </span><span class="p">(</span><span class="n">prevdata</span><span class="p">[</span><span class="n">jp</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">prevdata</span><span class="p">[</span><span class="n">jm</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dy2</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>How do we fit the queue, buffer, and accessor concepts of SYCL in the
existing codebase?
We will have to modify a few aspects of the codebase, to make sure that
functions to be offloaded are aware of the queue. Data will have to be
wrapped into SYCL buffers.</p></li>
</ol>
<div class="admonition-sycl-heat-equation-mini-app-with-buffers-and-accessors exercise important admonition" id="exercise-4">
<p class="admonition-title">SYCL heat equation mini app with buffers and accessors</p>
<p>We will use the serial version of the mini-app as a scaffold for our port.
The code is in the <code class="docutils literal notranslate"><span class="pre">content/code/day-2/05_serial-heat-equation</span></code> folder.
You will have to <em>uncomment</em> some lines in the CMake script in order to build
the executable with SYCL support.
A working solution is in the <code class="docutils literal notranslate"><span class="pre">content/code/day-2/06_sycl-heat-equation</span></code>
folder.</p>
<p>Let’s start from the top, <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code>, and more down to the stencil
application function in <code class="docutils literal notranslate"><span class="pre">core.cpp</span></code>. Compile after each step and fix
compiler errors before moving on to the next step.</p>
<ol class="arabic">
<li><p>As usual, we first create a queue and map it to the GPU, either explicitly:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">queue</span><span class="w"> </span><span class="n">Q</span><span class="p">{</span><span class="n">gpu_selector</span><span class="p">{}};</span>
</pre></div>
</div>
<p>or implicitly, by compiling with the appropriate <code class="docutils literal notranslate"><span class="pre">HIPSYCL_TARGETS</span></code> value.</p>
</li>
<li><p>The queue needs to be passed into the <code class="docutils literal notranslate"><span class="pre">evolve</span></code> function.  Compiling now
should raise an error, because no overload of this function accepting a
<code class="docutils literal notranslate"><span class="pre">queue</span></code> is known. Fix the compiler errors by redefining the function or
providing an overload.  Don’t change the implementation in <code class="docutils literal notranslate"><span class="pre">core.cpp</span></code>
yet.</p></li>
</ol>
<p>We can now work on the parallel implementation:</p>
<ol class="arabic">
<li><p>Obtain grid sizes in the <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> directions from the
<code class="docutils literal notranslate"><span class="pre">curr</span></code> input parameter.</p></li>
<li><p>Obtain denominator of the finite-difference formula in both Cartesian
directions:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dx</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">dy2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">dy</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p>We open a new scope for our SYCL work and declare buffers mapping to the
data underlying the <code class="docutils literal notranslate"><span class="pre">curr</span></code> and <code class="docutils literal notranslate"><span class="pre">prev</span></code> data structures for the heat
field:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">buffer</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buf_curr</span><span class="p">{</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">buf_prev</span><span class="p">{</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">};</span>
</pre></div>
</div>
<p>What are the dimensions of the iteration spaces given as second argument
to the buffer constructors?  Remember that the edges of the grid
accomodate the fixed boundary conditions!</p>
</li>
<li><p>With buffers at hand, we’re ready to submit work to the queue:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Q</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">handler</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cgh</span><span class="p">){</span>
<span class="w">   </span><span class="cm">/* body */</span>
<span class="p">});</span>
</pre></div>
</div>
</li>
<li><p>First, declare accessors with appropriate targets, since <code class="docutils literal notranslate"><span class="pre">curr</span></code> is
read-write, but <code class="docutils literal notranslate"><span class="pre">prev</span></code> is read-only:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">acc_curr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">accessor</span><span class="p">(</span><span class="n">buf_curr</span><span class="p">,</span><span class="w"> </span><span class="n">cgh</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">acc_prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">accessor</span><span class="p">(</span><span class="n">buf_prev</span><span class="p">,</span><span class="w"> </span><span class="n">cgh</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
</pre></div>
</div>
</li>
<li><p>To start with, we use a basic data-parallel kernel. Add a <code class="docutils literal notranslate"><span class="pre">parallel_for</span></code>
to the command-group handler:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cgh</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">(</span><span class="n">range</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(...,</span><span class="w"> </span><span class="p">...),</span><span class="w"> </span><span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="n">id</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cm">/* kernel body */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>What are the extents of the <code class="docutils literal notranslate"><span class="pre">range</span></code> object passed as first argument?
Remember that the zeroth and last elements in each dimension accommodate
the values <strong>fixed</strong> by the boundary conditions!</p>
</li>
<li><p>The buffers and accessors reinterpret the data in the 1-dimensional
<code class="docutils literal notranslate"><span class="pre">data</span></code> arrays of the <code class="docutils literal notranslate"><span class="pre">field</span></code> data structures as 2-dimensional objects.
We need to obtain the correct row and column indices:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
</pre></div>
</div>
<p>Once again, remember that the zeroth and last elements in each dimension
accommodate the values <strong>fixed</strong> by the boundary conditions!</p>
</li>
<li><p>Finally, apply the stencil:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">acc_curr</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">acc_prev</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span>
<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dt</span><span class="w"> </span><span class="o">*</span>
<span class="w">    </span><span class="p">((</span><span class="n">acc_prev</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">acc_prev</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">acc_prev</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dx2</span><span class="w"> </span><span class="o">+</span>
<span class="w">     </span><span class="p">(</span><span class="n">acc_prev</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">acc_prev</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">acc_prev</span><span class="p">[</span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dy2</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ol>
<p>The star and stop timers surrounding the time evolution loop in <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code>
can be used to give a rough estimate of the performance. Compare the serial
and SYCL versions of the code? What do you notice?
At a glance, do you think this is the best SYCL version of the app we can
write?</p>
</div>
<div class="admonition-keypoints keypoints admonition" id="keypoints-0">
<p class="admonition-title">Keypoints</p>
<ul class="simple">
<li><p>The heat equation is discretized in space and time</p></li>
<li><p>The implementation has loops over time and spatial dimensions</p></li>
<li><p>The implementation reports on the contents of the grid so we can understand
correctness and performance easily.</p></li>
</ul>
</div>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id3" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">*</a><span class="fn-bracket">]</span></span>
<p>The mini-app has support for writing an image file that shows the state of the
grid every 1500 steps.  Below we can see the progression over larger numbers of
steps:</p>
<figure class="align-center" id="id7">
<img alt="../_images/heat_montage.png" src="../_images/heat_montage.png" />
<figcaption>
<p><span class="caption-text">Over time, the grid progresses from the initial state toward
an end state where one triangle is cold and one is warm.
The average temperature tends to 45.</span><a class="headerlink" href="#id7" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>We can use this visualization to check that our attempts at parallelization are
working correctly.  Perhaps some bugs can be resolved by seeing what distortions
they introduce.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The PNG library is available as a module on the Karolina supercomputer:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$ </span>module<span class="w"> </span>load<span class="w"> </span>libpng
</pre></div>
</div>
</div>
</aside>
</aside>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../task-graphs-synchronization/" class="btn btn-neutral float-left" title="The task graph: data, dependencies, synchronization" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../sub-groups/" class="btn btn-neutral float-right" title="Using sub-groups in SYCL" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Roberto Di Remigio and individual contributors..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>